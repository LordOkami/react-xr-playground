{"ast":null,"code":"import _objectSpread from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncToGenerator from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\n\n/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\nvar Constants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n  ButtonTouchThreshold: 0.05,\n  AxisTouchThreshold: 0.1,\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\n\nfunction fetchJsonFile(_x) {\n  return _fetchJsonFile.apply(this, arguments);\n}\n\nfunction _fetchJsonFile() {\n  _fetchJsonFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(path);\n\n          case 2:\n            response = _context.sent;\n\n            if (response.ok) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error(response.statusText);\n\n          case 7:\n            return _context.abrupt(\"return\", response.json());\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchJsonFile.apply(this, arguments);\n}\n\nfunction fetchProfilesList(_x2) {\n  return _fetchProfilesList.apply(this, arguments);\n}\n\nfunction _fetchProfilesList() {\n  _fetchProfilesList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(basePath) {\n    var profileListFileName, profilesList;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (basePath) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error('No basePath supplied');\n\n          case 2:\n            profileListFileName = 'profilesList.json';\n            _context2.next = 5;\n            return fetchJsonFile(\"\".concat(basePath, \"/\").concat(profileListFileName));\n\n          case 5:\n            profilesList = _context2.sent;\n            return _context2.abrupt(\"return\", profilesList);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchProfilesList.apply(this, arguments);\n}\n\nfunction fetchProfile(_x3, _x4) {\n  return _fetchProfile.apply(this, arguments);\n}\n/** @constant {Object} */\n\n\nfunction _fetchProfile() {\n  _fetchProfile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(xrInputSource, basePath) {\n    var defaultProfile,\n        getAssetPath,\n        supportedProfilesList,\n        match,\n        supportedProfile,\n        profile,\n        assetPath,\n        layout,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            defaultProfile = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : null;\n            getAssetPath = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : true;\n\n            if (xrInputSource) {\n              _context3.next = 4;\n              break;\n            }\n\n            throw new Error('No xrInputSource supplied');\n\n          case 4:\n            if (basePath) {\n              _context3.next = 6;\n              break;\n            }\n\n            throw new Error('No basePath supplied');\n\n          case 6:\n            _context3.next = 8;\n            return fetchProfilesList(basePath);\n\n          case 8:\n            supportedProfilesList = _context3.sent;\n            xrInputSource.profiles.some(function (profileId) {\n              var supportedProfile = supportedProfilesList[profileId];\n\n              if (supportedProfile) {\n                match = {\n                  profileId: profileId,\n                  profilePath: \"\".concat(basePath, \"/\").concat(supportedProfile.path),\n                  deprecated: !!supportedProfile.deprecated\n                };\n              }\n\n              return !!match;\n            });\n\n            if (match) {\n              _context3.next = 17;\n              break;\n            }\n\n            if (defaultProfile) {\n              _context3.next = 13;\n              break;\n            }\n\n            throw new Error('No matching profile name found');\n\n          case 13:\n            supportedProfile = supportedProfilesList[defaultProfile];\n\n            if (supportedProfile) {\n              _context3.next = 16;\n              break;\n            }\n\n            throw new Error(\"No matching profile name found and default profile \\\"\".concat(defaultProfile, \"\\\" missing.\"));\n\n          case 16:\n            match = {\n              profileId: defaultProfile,\n              profilePath: \"\".concat(basePath, \"/\").concat(supportedProfile.path),\n              deprecated: !!supportedProfile.deprecated\n            };\n\n          case 17:\n            _context3.next = 19;\n            return fetchJsonFile(match.profilePath);\n\n          case 19:\n            profile = _context3.sent;\n\n            if (!getAssetPath) {\n              _context3.next = 25;\n              break;\n            }\n\n            if (xrInputSource.handedness === 'any') {\n              layout = profile.layouts[Object.keys(profile.layouts)[0]];\n            } else {\n              layout = profile.layouts[xrInputSource.handedness];\n            }\n\n            if (layout) {\n              _context3.next = 24;\n              break;\n            }\n\n            throw new Error(\"No matching handedness, \".concat(xrInputSource.handedness, \", in profile \").concat(match.profileId));\n\n          case 24:\n            if (layout.assetPath) {\n              assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n            }\n\n          case 25:\n            return _context3.abrupt(\"return\", {\n              profile: profile,\n              assetPath: assetPath\n            });\n\n          case 26:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _fetchProfile.apply(this, arguments);\n}\n\nvar defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: Constants.ComponentState.DEFAULT\n};\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\n\nfunction normalizeAxes() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var xAxis = x;\n  var yAxis = y; // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n\n  var hypotenuse = Math.sqrt(x * x + y * y);\n\n  if (hypotenuse > 1) {\n    var theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  } // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n\n\n  var result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5\n  };\n  return result;\n}\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\n\n\nvar VisualResponse = /*#__PURE__*/function () {\n  function VisualResponse(visualResponseDescription) {\n    _classCallCheck(this, VisualResponse);\n\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    } // Initializes the response's current value based on default data\n\n\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n\n\n  _createClass(VisualResponse, [{\n    key: \"updateFromComponent\",\n    value: function updateFromComponent(_ref) {\n      var xAxis = _ref.xAxis,\n          yAxis = _ref.yAxis,\n          button = _ref.button,\n          state = _ref.state;\n\n      var _normalizeAxes = normalizeAxes(xAxis, yAxis),\n          normalizedXAxis = _normalizeAxes.normalizedXAxis,\n          normalizedYAxis = _normalizeAxes.normalizedYAxis;\n\n      switch (this.componentProperty) {\n        case Constants.ComponentProperty.X_AXIS:\n          this.value = this.states.includes(state) ? normalizedXAxis : 0.5;\n          break;\n\n        case Constants.ComponentProperty.Y_AXIS:\n          this.value = this.states.includes(state) ? normalizedYAxis : 0.5;\n          break;\n\n        case Constants.ComponentProperty.BUTTON:\n          this.value = this.states.includes(state) ? button : 0;\n          break;\n\n        case Constants.ComponentProperty.STATE:\n          if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\n            this.value = this.states.includes(state);\n          } else {\n            this.value = this.states.includes(state) ? 1.0 : 0.0;\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unexpected visualResponse componentProperty \".concat(this.componentProperty));\n      }\n    }\n  }]);\n\n  return VisualResponse;\n}();\n\nvar Component = /*#__PURE__*/function () {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  function Component(componentId, componentDescription) {\n    var _this = this;\n\n    _classCallCheck(this, Component);\n\n    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName; // Build all the visual responses for this component\n\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach(function (responseName) {\n      var visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      _this.visualResponses[responseName] = visualResponse;\n    }); // Set default values\n\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n    this.values = {\n      state: Constants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined\n    };\n  }\n\n  _createClass(Component, [{\n    key: \"data\",\n    get: function get() {\n      var data = _objectSpread({\n        id: this.id\n      }, this.values);\n\n      return data;\n    }\n    /**\n     * @description Poll for updated data based on current gamepad state\n     * @param {Object} gamepad - The gamepad object from which the component data should be polled\n     */\n\n  }, {\n    key: \"updateFromGamepad\",\n    value: function updateFromGamepad(gamepad) {\n      var _this2 = this;\n\n      // Set the state to default before processing other data sources\n      this.values.state = Constants.ComponentState.DEFAULT; // Get and normalize button\n\n      if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\n        var gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n        this.values.button = gamepadButton.value;\n        this.values.button = this.values.button < 0 ? 0 : this.values.button;\n        this.values.button = this.values.button > 1 ? 1 : this.values.button; // Set the state based on the button\n\n        if (gamepadButton.pressed || this.values.button === 1) {\n          this.values.state = Constants.ComponentState.PRESSED;\n        } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\n          this.values.state = Constants.ComponentState.TOUCHED;\n        }\n      } // Get and normalize x axis value\n\n\n      if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\n        this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n        this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;\n        this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis; // If the state is still default, check if the xAxis makes it touched\n\n        if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\n          this.values.state = Constants.ComponentState.TOUCHED;\n        }\n      } // Get and normalize Y axis value\n\n\n      if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\n        this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n        this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;\n        this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis; // If the state is still default, check if the yAxis makes it touched\n\n        if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\n          this.values.state = Constants.ComponentState.TOUCHED;\n        }\n      } // Update the visual response weights based on the current component data\n\n\n      Object.values(this.visualResponses).forEach(function (visualResponse) {\n        visualResponse.updateFromComponent(_this2.values);\n      });\n    }\n  }]);\n\n  return Component;\n}();\n/**\n  * @description Builds a motion controller with components and visual responses based on the\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\n  * @author Nell Waliczek / https://github.com/NellWaliczek\n*/\n\n\nvar MotionController = /*#__PURE__*/function () {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  function MotionController(xrInputSource, profile, assetUrl) {\n    var _this3 = this;\n\n    _classCallCheck(this, MotionController);\n\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId; // Build child components as described in the profile description\n\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach(function (componentId) {\n      var componentDescription = _this3.layoutDescription.components[componentId];\n      _this3.components[componentId] = new Component(componentId, componentDescription);\n    }); // Initialize components based on current gamepad state\n\n    this.updateFromGamepad();\n  }\n\n  _createClass(MotionController, [{\n    key: \"gripSpace\",\n    get: function get() {\n      return this.xrInputSource.gripSpace;\n    }\n  }, {\n    key: \"targetRaySpace\",\n    get: function get() {\n      return this.xrInputSource.targetRaySpace;\n    }\n    /**\n     * @description Returns a subset of component data for simplified debugging\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      var data = [];\n      Object.values(this.components).forEach(function (component) {\n        data.push(component.data);\n      });\n      return data;\n    }\n    /**\n     * @description Poll for updated data based on current gamepad state\n     */\n\n  }, {\n    key: \"updateFromGamepad\",\n    value: function updateFromGamepad() {\n      var _this4 = this;\n\n      Object.values(this.components).forEach(function (component) {\n        component.updateFromGamepad(_this4.xrInputSource.gamepad);\n      });\n    }\n  }]);\n\n  return MotionController;\n}();\n\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };","map":{"version":3,"sources":["/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/@webxr-input-profiles/motion-controllers/dist/motion-controllers.module.js"],"names":["Constants","Handedness","Object","freeze","NONE","LEFT","RIGHT","ComponentState","DEFAULT","TOUCHED","PRESSED","ComponentProperty","BUTTON","X_AXIS","Y_AXIS","STATE","ComponentType","TRIGGER","SQUEEZE","TOUCHPAD","THUMBSTICK","ButtonTouchThreshold","AxisTouchThreshold","VisualResponseProperty","TRANSFORM","VISIBILITY","fetchJsonFile","path","fetch","response","ok","Error","statusText","json","fetchProfilesList","basePath","profileListFileName","profilesList","fetchProfile","xrInputSource","defaultProfile","getAssetPath","supportedProfilesList","profiles","some","profileId","supportedProfile","match","profilePath","deprecated","profile","handedness","layout","layouts","keys","assetPath","replace","defaultComponentValues","xAxis","yAxis","button","state","normalizeAxes","x","y","hypotenuse","Math","sqrt","theta","atan2","cos","sin","result","normalizedXAxis","normalizedYAxis","VisualResponse","visualResponseDescription","componentProperty","states","valueNodeName","valueNodeProperty","minNodeName","maxNodeName","value","updateFromComponent","includes","Component","componentId","componentDescription","visualResponses","gamepadIndices","length","id","type","rootNodeName","touchPointNodeName","forEach","responseName","visualResponse","assign","values","undefined","data","gamepad","buttons","gamepadButton","pressed","touched","axes","abs","MotionController","assetUrl","layoutDescription","components","updateFromGamepad","gripSpace","targetRaySpace","component","push"],"mappings":"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","sourcesContent":["/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nconst Constants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath);\n\n  // Find the relative path to the first requested profile that is recognized\n  let match;\n  xrInputSource.profiles.some((profileId) => {\n    const supportedProfile = supportedProfilesList[profileId];\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n\n  let assetPath;\n  if (getAssetPath) {\n    let layout;\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n    if (!layout) {\n      throw new Error(\n        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`\n      );\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return { profile, assetPath };\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: Constants.ComponentState.DEFAULT\n};\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y;\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt((x * x) + (y * y));\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: (xAxis * 0.5) + 0.5,\n    normalizedYAxis: (yAxis * 0.5) + 0.5\n  };\n  return result;\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis, yAxis, button, state\n  }) {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);\n    switch (this.componentProperty) {\n      case Constants.ComponentProperty.X_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.Y_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.BUTTON:\n        this.value = (this.states.includes(state)) ? button : 0;\n        break;\n      case Constants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\n          this.value = (this.states.includes(state));\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n        break;\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId\n     || !componentDescription\n     || !componentDescription.visualResponses\n     || !componentDescription.gamepadIndices\n     || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\n\n    // Build all the visual responses for this component\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    });\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n\n    this.values = {\n      state: Constants.ComponentState.DEFAULT,\n      button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,\n      xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,\n      yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = { id: this.id, ...this.values };\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = Constants.ComponentState.DEFAULT;\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined\n        && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = (this.values.button < 0) ? 0 : this.values.button;\n      this.values.button = (this.values.button > 1) ? 1 : this.values.button;\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = Constants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;\n      this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;\n      this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n}\n\n/**\n  * @description Builds a motion controller with components and visual responses based on the\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\n  * @author Nell Waliczek / https://github.com/NellWaliczek\n*/\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId;\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    });\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data);\n    });\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad() {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n}\n\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };\n"]},"metadata":{},"sourceType":"module"}