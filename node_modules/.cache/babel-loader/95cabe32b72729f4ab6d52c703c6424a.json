{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nvar shaderStages = ['fragment', 'vertex'];\nvar vector = ['x', 'y', 'z', 'w'];\n\nvar toFloat = function toFloat(value) {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(object, renderer, parser) {\n    _classCallCheck(this, NodeBuilder);\n\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  _createClass(NodeBuilder, [{\n    key: \"addStack\",\n    value: function addStack(node) {\n      /*\n      if ( this.stack.indexOf( node ) !== - 1 ) {\n      console.warn( 'Recursive node: ', node );\n      }\n      */\n      this.stack.push(node);\n    }\n  }, {\n    key: \"removeStack\",\n    value: function removeStack(node) {\n      var lastStack = this.stack.pop();\n\n      if (lastStack !== node) {\n        throw new Error('NodeBuilder: Invalid node stack!');\n      }\n    }\n  }, {\n    key: \"setHashNode\",\n    value: function setHashNode(node, hash) {\n      this.hashNodes[hash] = node;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (this.nodes.indexOf(node) === -1) {\n        var updateType = node.getUpdateType(this);\n\n        if (updateType !== NodeUpdateType.None) {\n          this.updateNodes.push(node);\n        }\n\n        this.nodes.push(node);\n        this.setHashNode(node, node.getHash(this));\n      }\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getNodeFromHash\",\n    value: function getNodeFromHash(hash) {\n      return this.hashNodes[hash];\n    }\n  }, {\n    key: \"addFlow\",\n    value: function addFlow(shaderStage, node) {\n      this.flowNodes[shaderStage].push(node);\n      return node;\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      this.context = context;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getTextureBias\",\n    value: function getTextureBias() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTexture\",\n    value: function getCubeTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTextureBias\",\n    value: function getCubeTextureBias() {\n      console.warn('Abstract function.');\n    } // @TODO: rename to .generateConst()\n\n  }, {\n    key: \"getConst\",\n    value: function getConst(type, value) {\n      var _this = this;\n\n      if (type === 'float') return toFloat(value);\n      if (type === 'int') return \"\".concat(Math.round(value));\n      if (type === 'uint') return value >= 0 ? \"\".concat(Math.round(value), \"u\") : '0u';\n      if (type === 'bool') return value ? 'true' : 'false';\n      if (type === 'color') return \"\".concat(this.getType('vec3'), \"( \").concat(toFloat(value.r), \", \").concat(toFloat(value.g), \", \").concat(toFloat(value.b), \" )\");\n      var typeLength = this.getTypeLength(type);\n      var componentType = this.getComponentType(type);\n\n      var getConst = function getConst(value) {\n        return _this.getConst(componentType, value);\n      };\n\n      if (typeLength === 2) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \" )\");\n      } else if (typeLength === 3) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \" )\");\n      } else if (typeLength === 4) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \", \").concat(getConst(value.w), \" )\");\n      }\n\n      throw new Error(\"NodeBuilder: Type '\".concat(type, \"' not found in generate constant attempt.\"));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      return type;\n    }\n  }, {\n    key: \"generateMethod\",\n    value: function generateMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name, type) {\n      var attributes = this.attributes; // find attribute\n\n      var _iterator = _createForOfIteratorHelper(attributes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _attribute = _step.value;\n\n          if (_attribute.name === name) {\n            return _attribute;\n          }\n        } // create a new if no exist\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var attribute = new NodeAttribute(name, type);\n      attributes.push(attribute);\n      return attribute;\n    }\n  }, {\n    key: \"getPropertyName\",\n    value: function getPropertyName(node\n    /*, shaderStage*/\n    ) {\n      return node.name;\n    }\n  }, {\n    key: \"isVector\",\n    value: function isVector(type) {\n      return /vec\\d/.test(type);\n    }\n  }, {\n    key: \"isMatrix\",\n    value: function isMatrix(type) {\n      return /mat\\d/.test(type);\n    }\n  }, {\n    key: \"isReference\",\n    value: function isReference(type) {\n      return type === 'void' || type === 'property' || type === 'sampler';\n    }\n  }, {\n    key: \"isShaderStage\",\n    value: function isShaderStage(shaderStage) {\n      return this.shaderStage === shaderStage;\n    }\n  }, {\n    key: \"getTextureEncodingFromMap\",\n    value: function getTextureEncodingFromMap(map) {\n      var encoding;\n\n      if (map && map.isTexture) {\n        encoding = map.encoding;\n      } else if (map && map.isWebGLRenderTarget) {\n        encoding = map.texture.encoding;\n      } else {\n        encoding = LinearEncoding;\n      }\n\n      return encoding;\n    }\n  }, {\n    key: \"getComponentType\",\n    value: function getComponentType(type) {\n      type = this.getVectorType(type);\n      var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n      if (componentType === null) return null;\n      if (componentType[1] === 'b') return 'bool';\n      if (componentType[1] === 'i') return 'int';\n      if (componentType[1] === 'u') return 'uint';\n      return 'float';\n    }\n  }, {\n    key: \"getVectorType\",\n    value: function getVectorType(type) {\n      if (type === 'color') return 'vec3';\n      if (type === 'texture') return 'vec4';\n      return type;\n    }\n  }, {\n    key: \"getTypeFromLength\",\n    value: function getTypeFromLength(type) {\n      if (type === 1) return 'float';\n      if (type === 2) return 'vec2';\n      if (type === 3) return 'vec3';\n      if (type === 4) return 'vec4';\n      return 0;\n    }\n  }, {\n    key: \"getTypeLength\",\n    value: function getTypeLength(type) {\n      var vecType = this.getVectorType(type);\n      var vecNum = /vec([2-4])/.exec(vecType);\n      if (vecNum !== null) return Number(vecNum[1]);\n      if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n      return 0;\n    }\n  }, {\n    key: \"getVectorFromMatrix\",\n    value: function getVectorFromMatrix(type) {\n      return type.replace('mat', 'vec');\n    }\n  }, {\n    key: \"getDataFromNode\",\n    value: function getDataFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var nodeData = this.nodesData.get(node);\n\n      if (nodeData === undefined) {\n        nodeData = {\n          vertex: {},\n          fragment: {}\n        };\n        this.nodesData.set(node, nodeData);\n      }\n\n      return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n    }\n  }, {\n    key: \"getUniformFromNode\",\n    value: function getUniformFromNode(node, shaderStage, type) {\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeUniform = nodeData.uniform;\n\n      if (nodeUniform === undefined) {\n        var index = this.uniforms.index++;\n        nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n        this.uniforms[shaderStage].push(nodeUniform);\n        nodeData.uniform = nodeUniform;\n      }\n\n      return nodeUniform;\n    }\n  }, {\n    key: \"getVarFromNode\",\n    value: function getVarFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeVar = nodeData.variable;\n\n      if (nodeVar === undefined) {\n        var vars = this.vars[shaderStage];\n        var index = vars.length;\n        nodeVar = new NodeVar('nodeVar' + index, type);\n        vars.push(nodeVar);\n        nodeData.variable = nodeVar;\n      }\n\n      return nodeVar;\n    }\n  }, {\n    key: \"getVaryFromNode\",\n    value: function getVaryFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node, null);\n      var nodeVary = nodeData.vary;\n\n      if (nodeVary === undefined) {\n        var varys = this.varys;\n        var index = varys.length;\n        nodeVary = new NodeVary('nodeVary' + index, type);\n        varys.push(nodeVary);\n        nodeData.vary = nodeVary;\n      }\n\n      return nodeVary;\n    }\n  }, {\n    key: \"getCodeFromNode\",\n    value: function getCodeFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node);\n      var nodeCode = nodeData.code;\n\n      if (nodeCode === undefined) {\n        var codes = this.codes[shaderStage];\n        var index = codes.length;\n        nodeCode = new NodeCode('nodeCode' + index, type);\n        codes.push(nodeCode);\n        nodeData.code = nodeCode;\n      }\n\n      return nodeCode;\n    }\n  }, {\n    key: \"addFlowCode\",\n    value: function addFlowCode(code) {\n      this.flow.code += code;\n    }\n  }, {\n    key: \"getFlowData\",\n    value: function getFlowData(shaderStage, node) {\n      return this.flowsData.get(node);\n    }\n  }, {\n    key: \"flowNode\",\n    value: function flowNode(node) {\n      this.node = node;\n      var output = node.getNodeType(this);\n      var flowData = this.flowChildNode(node, output);\n      this.flowsData.set(node, flowData);\n      this.node = null;\n      return flowData;\n    }\n  }, {\n    key: \"flowChildNode\",\n    value: function flowChildNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      flow.result = node.build(this, output);\n      this.flow = previousFlow;\n      return flow;\n    }\n  }, {\n    key: \"flowNodeFromShaderStage\",\n    value: function flowNodeFromShaderStage(shaderStage, node) {\n      var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var previousShaderStage = this.shaderStage;\n      this.setShaderStage(shaderStage);\n      var flowData = this.flowChildNode(node, output);\n\n      if (propertyName !== null) {\n        flowData.code += \"\".concat(propertyName, \" = \").concat(flowData.result, \";\\n\\t\");\n      }\n\n      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n      this.setShaderStage(previousShaderStage);\n      return flowData;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVarys\",\n    value: function getVarys() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVars\",\n    value: function getVars(shaderStage) {\n      var snippet = '';\n      var vars = this.vars[shaderStage];\n\n      for (var index = 0; index < vars.length; index++) {\n        var variable = vars[index];\n        snippet += \"\".concat(variable.type, \" \").concat(variable.name, \"; \");\n      }\n\n      return snippet;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCodes\",\n    value: function getCodes(shaderStage) {\n      var codes = this.codes[shaderStage];\n      var code = '';\n\n      var _iterator2 = _createForOfIteratorHelper(codes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var nodeCode = _step2.value;\n          code += nodeCode.code + '\\n';\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return code;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.vertexShader + this.fragmentShader;\n    }\n  }, {\n    key: \"getShaderStage\",\n    value: function getShaderStage() {\n      return this.shaderStage;\n    }\n  }, {\n    key: \"setShaderStage\",\n    value: function setShaderStage(shaderStage) {\n      this.shaderStage = shaderStage;\n    }\n  }, {\n    key: \"buildCode\",\n    value: function buildCode() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      // stage 1: analyze nodes to possible optimization and validation\n      var _iterator3 = _createForOfIteratorHelper(shaderStages),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var shaderStage = _step3.value;\n          this.setShaderStage(shaderStage);\n          var flowNodes = this.flowNodes[shaderStage];\n\n          var _iterator5 = _createForOfIteratorHelper(flowNodes),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var node = _step5.value;\n              node.analyze(this);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        } // stage 2: pre-build vertex code used in fragment shader\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      } // stage 3: generate shader\n\n\n      var _iterator4 = _createForOfIteratorHelper(shaderStages),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _shaderStage = _step4.value;\n          this.setShaderStage(_shaderStage);\n          var _flowNodes = this.flowNodes[_shaderStage];\n\n          var _iterator6 = _createForOfIteratorHelper(_flowNodes),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _node = _step6.value;\n              this.flowNode(_node, _shaderStage);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.setShaderStage(null); // stage 4: build code for a specific output\n\n      this.buildCode();\n      return this;\n    }\n  }, {\n    key: \"format\",\n    value: function format(snippet, fromType, toType) {\n      fromType = this.getVectorType(fromType);\n      toType = this.getVectorType(toType);\n\n      if (fromType === toType || toType === null || this.isReference(toType)) {\n        return snippet;\n      }\n\n      var fromTypeLength = this.getTypeLength(fromType);\n      var toTypeLength = this.getTypeLength(toType);\n\n      if (fromTypeLength === 0) {\n        // fromType is matrix-like\n        var vectorType = this.getVectorFromMatrix(fromType);\n        return this.format(\"( \".concat(snippet, \" * \").concat(this.getType(vectorType), \"( 1.0 ) )\"), vectorType, toType);\n      }\n\n      if (toTypeLength === 0) {\n        // toType is matrix-like\n        // ignore for now\n        //return `${ this.getType( toType ) }( ${ snippet } )`;\n        return snippet;\n      }\n\n      if (fromTypeLength === toTypeLength) {\n        return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\");\n      }\n\n      if (fromTypeLength > toTypeLength) {\n        return this.format(\"\".concat(snippet, \".\").concat('xyz'.slice(0, toTypeLength)), this.getTypeFromLength(toTypeLength), toType);\n      }\n\n      if (toTypeLength === 4) {\n        // toType is vec4-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec3'), \", 1.0 )\");\n      }\n\n      if (fromTypeLength === 2) {\n        // fromType is vec2-like and toType is vec3-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec2'), \", 0.0 )\");\n      }\n\n      return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\"); // fromType is float-like\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return \"// Three.js r\".concat(REVISION, \" - NodeMaterial System\\n\");\n    }\n  }]);\n\n  return NodeBuilder;\n}();\n\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"sources":["/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","object","renderer","parser","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","push","lastStack","pop","Error","hash","indexOf","updateType","getUpdateType","None","setHashNode","getHash","method","console","warn","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","getConst","x","y","z","w","name","attribute","test","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","vecType","vecNum","replace","nodeData","get","undefined","set","getDataFromNode","nodeUniform","uniform","nodeVar","variable","length","nodeVary","vary","nodeCode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","propertyName","previousShaderStage","setShaderStage","snippet","analyze","isNode","flowNodeFromShaderStage","flowNode","buildCode","fromType","toType","isReference","fromTypeLength","toTypeLength","vectorType","getVectorFromMatrix","format","slice","getTypeFromLength"],"mappings":"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","sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"]},"metadata":{},"sourceType":"module"}