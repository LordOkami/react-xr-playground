import { useRef, useCallback, useMemo, useEffect, useDebugValue } from 'react';
import { isChanged, createProxy, affectedToPathList } from 'proxy-compare';
import { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';
import { subscribe, snapshot, getVersion } from 'valtio/vanilla';
export { getVersion, proxy, ref, snapshot, subscribe, getHandler as unstable_getHandler } from 'valtio/vanilla';

const useAffectedDebugValue = (state, affected) => {
  const pathList = useRef();
  useEffect(() => {
    pathList.current = affectedToPathList(state, affected);
  });
  useDebugValue(pathList.current);
};
function useSnapshot(proxyObject, options) {
  const affected = /* @__PURE__ */ new WeakMap();
  const lastAffected = useRef();
  const lastCallback = useRef();
  const notifyInSync = options == null ? void 0 : options.sync;
  const currSnapshot = useSyncExternalStore(useCallback((callback) => {
    lastCallback.current = callback;
    const unsub = subscribe(proxyObject, callback, notifyInSync);
    return () => {
      unsub();
      lastCallback.current = void 0;
    };
  }, [proxyObject, notifyInSync]), useMemo(() => {
    let prevSnapshot;
    return () => {
      const nextSnapshot = snapshot(proxyObject);
      try {
        if (prevSnapshot && lastAffected.current && !isChanged(prevSnapshot, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return prevSnapshot;
        }
      } catch (e) {
      }
      return prevSnapshot = nextSnapshot;
    };
  }, [proxyObject]), useCallback(() => snapshot(proxyObject), [proxyObject]));
  const currVersion = getVersion(proxyObject);
  useEffect(() => {
    lastAffected.current = affected;
    if (currVersion !== getVersion(proxyObject)) {
      if (lastCallback.current) {
        lastCallback.current();
      } else if (typeof process === "object" && process.env.NODE_ENV !== "production") {
        console.warn("[Bug] last callback is undefined");
      }
    }
  });
  if ((import.meta.env && import.meta.env.MODE) !== "production") {
    useAffectedDebugValue(currSnapshot, affected);
  }
  const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, affected, proxyCache);
}

export { useSnapshot };
